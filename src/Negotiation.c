/**
 * @file    Negotiation.c
 * 
 * This file implements the first part of the game that decides who goes first 
 * based on a coin flip.
 *
 * @author Akshera Paladhi (apaladhi@ucsc.edu)
 * @date June 8, 2025
 */

 #include <stdint.h>

 /**
  * The outcome of the negotiation is a coin flip and can be either HEADS or TAILS.
  */
 typedef enum {
     HEADS,
     TAILS,
 } NegotiationOutcome;
 
 /**
  * All negotiation data is transmitted as uniformly-sized data packets.
  */
 typedef uint16_t NegotiationData;
 
 /**
  * The commitment packet is generated using a hash that utilizes a public key,
  * defined here:
  */
 #define PUBLIC_KEY 0xBEEF
 #define TRUE 1
 #define FALSE 0
 
 /**
  * Implements a one-way hash function. It maps its input, 'secret',
  * into a hash value in a way that is hard to reverse but easy to reproduce.
  * 
  * This function implements the "Beef Hash," a variant of a Rabin hash.
  * The result is ((secret squared) modulo the constant key 0xBEEF).
  * 
  * For example:
  *  NegotiationHash(3) == 9
  *  NegotiationHash(12345) == 43182
  *
  * @param secret  The secret number that a challenger commits to.
  * @return        The hashed value of the secret commitment.
  */
 NegotiationData NegotiationHash(NegotiationData secret) {
     return (secret * secret) % PUBLIC_KEY;
 }
 
 /**
  * Detects cheating by verifying that the revealed secret matches the 
  * original commitment hash.
  *
  * @param secret      The previously secret number revealed by the challenger.
  * @param commitment  The hash of the secret number originally sent.
  * @return            TRUE if the secret matches the commitment hash, FALSE otherwise.
  */
 int NegotiationVerify(NegotiationData secret, NegotiationData commitment) {
     if (NegotiationHash(secret) == commitment) {
         return TRUE;
     } else {
         return FALSE;
     }
 }
 
 /**
  * The coin-flip protocol uses random numbers generated by both agents 
  * to determine the outcome of the coin flip.
  *
  * The parity of a bitstring is 1 if there is an odd number of 1 bits,
  * and 0 otherwise.
  * 
  * For example, the number 0b01101011 has 5 ones. If the parity of A XOR B is 1,
  * the outcome is HEADS; otherwise, the outcome is TAILS.
  *
  * @param A  The random number from agent A.
  * @param B  The random number from agent B.
  * @return   The outcome of the coin flip (HEADS or TAILS).
  */
 NegotiationOutcome NegotiateCoinFlip(NegotiationData A, NegotiationData B) {
     NegotiationData C = A ^ B;
 
     int parity = 0;
     NegotiationData temp = C;
 
     // Calculate parity of C by XOR'ing all bits
     while (temp) {
         parity ^= (temp & 1);
         temp >>= 1;
     }
 
     if (parity == 1) {
         return HEADS;
     } else {
         return TAILS;
     }
 }
 
 /**
  * Extra credit:
  * These functions allow the creation of a "cheating" agent that can 
  * bias the coin flip outcome in their favor.
  *
  * To get extra credit, define and use these functions in agent.c to generate A and/or B.
  * Your agent only needs to cheat in one role, achieving a win rate > 75% against a fair agent.
  *
  * You must state this in your README and describe your cheating strategy thoroughly.
  */
 
 /**
  * Given a commitment hash (hash_a), find a secret A and a value B such that
  * the parity of A XOR B is 1 (HEADS). This allows generating B to force the outcome.
  *
  * @param hash_a  The commitment hash from the challenger.
  * @return        A value B that forces the coin flip to HEADS.
  */
 NegotiationData NegotiateGenerateBGivenHash(NegotiationData hash_a) {
     for (NegotiationData guess = 0; guess <= 0xFFFF; guess++) {
         if (NegotiationHash(guess) == hash_a) {
             NegotiationData A = guess;
             // Find B such that parity of A ^ B is 1 (HEADS)
             for (NegotiationData B = 1; B <= 0xFFFF; B++) {
                 NegotiationData C = A ^ B;
                 int parity = 0;
                 NegotiationData temp = C;
                 while (temp) {
                     parity ^= (temp & 1);
                     temp >>= 1;
                 }
                 if (parity == 1) {
                     return B;
                 }
             }
         }
     }
     return 0; // Fallback, should not happen
 }
 
 /**
  * Given B, find a secret A such that the parity of A XOR B is 1 (HEADS).
  *
  * @param B  The value from the other agent.
  * @return   A value A that forces the coin flip to HEADS.
  */
 NegotiationData NegotiateGenerateAGivenB(NegotiationData B) {
     for (NegotiationData A = 0; A <= 0xFFFF; A++) {
         NegotiationData C = A ^ B;
         int parity = 0;
         NegotiationData temp = C;
         while (temp) {
             parity ^= (temp & 1);
             temp >>= 1;
         }
         if (parity == 1) {
             return A;
         }
     }
     return 0; // Fallback, should not happen
 }
 