**ECE13 Lab10: Battleboats**

Date: June 8, 2025  
“Author: Akshera Paladhi (apaladhi@ucsc.edu)”  
“Partner: Caitelyn Huang (chuan188@ucsc.edu)  
“Collaborators: Ojashwini V Srinivasan (ovontivi@ucsc.edu) & Prithika Thanigaivelan (pthaniga@ucsc.edu) ”

We worked from the apaladhi Repo and our commit ID was:  
a64713ff22b000601463995cb3eece0fb3a34006

I wrote: 
Agent.c
Negotiation.c
MessageTest.c
FieldTest.c

Please note that my partner and I did not implement any of the extra credit properly. 

**Tell us about how you worked with your partner. Who wrote what? Do you think the work was fairly divided? Did each of you do the right amount of work, or did one of you work too little or too much?**  

My partner and I worked on it immediately after we turned in our Lab08 or the oven lab. Taking in the advice that the TAs and professor said, we decided to start early and our goal was that we would first start off by reading the lab manual separately on our own and then come together to see what we understand and answer each other’s questions on it. Then after reading the manual this helped us decide that I would be doing Agent.c, Negotiation.c, MessageTest.c, and FieldTest.c files while Caitelyn Huang would do AgentTest.c, NegotiationTest.c, Messaget.c, and Field.c files. I do think the work was fairly divided for the most part, but I did feel like because Agent.c file was the main file that controlled everything it had more debugging issues and so I felt like since I was the only one that understood it, I had to sit down and spend debugging while my partner could not help as much. However, I still think we did the same amount of work, but since Agent.c was particularly more important it had a lot more issues that I had to put more effort into solving since this was my file. Essentially, I felt like I spent more time debugging than my partner, but she still helped me out as much as she could and we divided the work equally. 

**Did you collaborate with anyone else? What was the nature of the collaboration?**

Yes, we did collaborate with another group and the nature of this collaboration was more that we had to kind of guide them through the code like the starting part. They were really confused so we just wanted to help them out and they also helped us realize some of our own bugs in our issue. So this was beneficial for both of us since we helped them out with their code just the starting part of Agent.c and while we helped them out, we figured some bugs in our issue. 
 
**Also tell us about any extra credit you did and how we can observe it in action.**  

We did not do the extra credit because it may be implemented in negotiation, but it was not put into agent.c so it does not do anything. But if we were to implement the extra credit it essentially is a cheating strategy that forced our agent to go first more than 75% of the time. So the function, NegotiateGenerateAGivenB() which, given the opponent’s value B, searches for a value A such that the result of A ^ B has odd parity, resulting in a coin flip outcome of heads. This guarantees that our agent wins the coin flip and goes first when it plays the challenger role and has the ability to choose A after receiving B. You can observe this action during the negotiation phase of the game, this will make you realize that the majority of the matches agent goes first. Essentially this is due to the fact that the function selects a value of A that manipulates the coin flip to its benefit. If you print the negotiation values (A, B, and A ^ B), you will notice that the XOR result always has odd parity, ensuring the outcome is HEADS. This confirms that the extra credit behavior is working as intended.

**Report:** 
**An overview of the BattleBoats system. Describe how it works, as you understand it.** 

The BattleBoats is a game that requires two players and it is played using the microcontrollers. Each player has their own board and their boats are randomly placed. The game flow involves sending and receiving structured messages over UART between agents which represent each player. First, players go through the negotiation file which determines who goes first and this file uses hashed values and secret numbers so there is no cheating. Then players take turns attacking at coordinates on the opponent's grid, then after each player goes, the receiving player sends a response to explain what kind of shot it was like: was it a hit, miss, or sunk a boat. This game uses a state machine to control all the different stages and it goes from start, challenging, accepting, attacking, defending, waiting to send, and ending. The game without the extra credit involves just the user to press btn 4 and the game is just played by the two microcontrollers. So it does not need a human to battle. Also, in order for the two microcontrollers to communicate and play, they need to be connected together using jumper wires. 

**What worked well? What didn’t? Describe at least one testing strategy you found effective.** 

Our code button 4 and button 1 worked well with starting and resetting. Additionally the attacking between the two players and defending, challenging, and accepting worked well. Essentially, our code ran with no warnings or errors and it battled, but it would only print defeat one partner’s OLED and the other would just stay frozen on the battlefield. I struggled a lot with debugging this part and also asked for help and just could not figure it out so I just left as it is and another bug in our issue was being able to switch the arrow back and forth to say whose turn it is. I still could not implement that part properly either. However, I did later understand that I should put playerTurn = FIELD_OLED_TURN_MINE and playerTurn = FIELD_OLED_TURN_THEIRS in the defending, attacking, accepting, and challenging in maybe all of them or two of them. Other than our code was compiling and playing the game. Also another issue that we faced was that it would only print “ALAS DEFEAT..” but no victory for the winning player, but because we did not have enough time we could not implement our solution, but we realized that the issue was that it was never reaching that if and else statement or end screen in attacking for some reason. We have not found out why. Another issue we were facing was that sometimes our OLED would just freeze and not attack or defend, but when resetted everything, it would work properly. My partner and I think it is not the logic in our code, but an issue with hardware because we were talking to one of the TAs and they mentioned that the OLED glitches and it happens to everyone. One testing strategy I found effective was since we had the solution code we would comment out all our code and then slowly uncomment each function to see exactly where our issue was. Then after that everything else was easier because we knew that the logic error had to be somewhere within that function. Usually our errors did end up being in Agent.c like how it would get frozen because I forgot to call OLED and or a certain function. Another thing that obviously helped was creating test cases since this checked if it was actually working so if a test case failed we knew exactly was not working. 

**What did you learn from this lab?** 

I learned from this lab that the way someone writes their code can change based on the device they are on sometimes and some errors are caused because of the hardwire. This is because our code would work most of the time but sometimes what would happen is randomly the words or drawings of the field and boats would randomly be shifted onto one side. We initially thought it was a logic error but when we unplugged and plugged back our nucleo the issue was fixed. I also understood how to more effectively do state machines because before in Lab08, I was struggling a lot to implement one properly. However, in this one, I feel like I did better job than before and I also understood that if you do not call FieldOled or any of the functions from Oled.h the oled will not be able to output any of the code or logic you put, so now that I understand that more clearly, the bugs in our code were more easier to fix. 

**What did you like about this lab? What would you change about this lab?**
I liked that this lab actually taught us how to build a game and this was definitely really difficult so that also made it more exciting. I found that there were issues in the solution given in the lab like the bug where the arrow does not change to say whose turn it is. Another thing is, I think we should have had maybe 3 more days for this lab because I know that not just my partner and I were struggling but many were finding it difficult to even get their code to compile. Additionally, there should be more detail on the lab about agent.c because the diagram was helpful for understanding the basic code structure, but it would have been even more useful if it had covered how to properly display the win and lose screens—since many students, including myself, struggled with that. It would also be beneficial to go over common issues that students have faced in the past or that graders frequently encounter. Providing example solutions to those issues, either in class or as additional resources, would greatly improve the learning experience.
